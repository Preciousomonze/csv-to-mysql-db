<?php
	//namespace pp\DB;
	
	/**
	 *  Query class
	 * 
	 * Has the necessary methods to carry out major query functions. flexing :)
	 * 
	 * @author Precious Omonzejele <crispusomonze@gmail.com>
	 */

	class Query extends DBCon{
		/**
		 * Stores the connection object, this is useful when a method closes a connection, so we can
		 * always reopen without stress
		 * @var object
		 */ 
		protected $con_clone = '';
		public $table = ''; 
		public $err_msg = ''; //stores the error message
		public $err_no = 0; //stores the error number
		public $last_err_msg = '';//stores the last error message
		public $last_err_no = '';//stores the last error number
		/**
		  * Determines which bind type to be used param or value
	      * @var string
		  */
		  private $bind_type = 'param';
		  
		/**
		  * To set the pdo param type when binding values, couldn't find a better way to do it
	      * @var PDO
		  */
		  public $pdo_param_type = PDO::PARAM_STR;
		  
		  /**
			* Stores last insert id after an insert query
			* @var int
			*/
			public $last_insert_id = 0;
		/**
     	 * stores the number of rows generated by a select statement
     	 * @var int
	 	 * @default 0;
     	 */
		  public $row_count = 0; 
		
		  /**
			* stores the affected rows in an update or delete statement
			* @var int
			* @default 0;
			*/
		  public $rows_affected = 0;
		  /**
		   * Stores the record of a select statement
		   * @var array
		   */
		  public $record = array();
		  /**
		   * Stores the record of a select statement,specially for PDO when the count_row is used
		   * 
		   * This is because the method uses the fetch all which empties the result, giving me issues
		   * this is my best way out for now :)
		   * @var array
		   */
		  private $_record_dummy = array();
		  /**
		   * stores the value of the fetch mode to use in a db fetch result
		   * 
		   * Note: for now, when using pdo mode and want to call the count_rows() before the get_record()
		   * method, please make sure you set the fetch_mode if need be , before calling the count_rows()
		   * because of the issue of calling the 2 methods together, one fetches the result and leaves the other 
		   * to fetch nothing, so the first one called stores the record temporarily so the second can also use.
		   * so to make your fetchmode take effect, you have to set it before calling the first method
		   * @var mixed
		   */
		  private $fetch_mode = '';
		protected $values,$condition,$content;
		protected $_bindings = null;//meant to be an array,stores the binding values in array format
		public $query_txt = '';//Query text
		protected $general_obj = null;//holds either the query object or prepared statement object depending on the situation.
		protected $query_obj = null;//holds the query object
		protected $prepared_obj = null;//holds the prepared statement object when a prepared statement is successful.
		protected $prepared_txt = '';//holds the $query_txt text when using a prepared statement.
		protected $sql_functions = array('now()','?');//stores the special functions of sql
		protected $sql_statement_for_count = array('select');//the type of statement that can be counted, didnt have a better name to give it
		protected $sql_statement_for_affected = array('insert','update','delete');//the type of statement that can be counted, didnt have a better name to give it
		
		/**
		 * Constructor
		 * 
		 * @param array $args, the array consisting of the connection object and db type
		 */
		function __construct($args){
			Parent::connect_obj($args[0]);
			//for reconnecting purpose
			$this->con_clone = $args[0];
			//the db type
			$this->db_type = $args[1];
			//set default fetch mode
			$this->set_fetch_mode();
		}
		
		/** 
		 * CSV sorting
		 * 
		 * @param string value, the value to edit
		*/
		private function csv($values){
			$delimeter = ",";
			$_values = explode($delimeter,$values);
			$store = "";//WHAT WILL STORE THE VALUES
			for($i = 0; $i < count($_values); $i++){
				//STORE THE VALUES
				$counting = count($_values) - $i;//DO ARITHMETIC STUFF TO KNOW WHEN IT'S THE LAST VALUE, SO AS TO REMOVE THE PUTTING OF THE COMMA
				if($counting > 1){
				$store += $_values[$i].",";	
				}
				else if ($counting == 1){//IT'S THE LAST VALUE.
				$store += $_values[$i];
				}
			}
			return $store;
		}

		
		/**
		 * for preparing statements
		 * 
		 * This is useful when you want to prepare the statement down, then maybe loop the execution or something
		 * to put in different values, otherwise, use the other functions for query execution
		 * 
		 * @param string $query: query to execute in the database
		 * @param array $bind_data: the values to bind in the query, single dimension array type, coming
		 * soon is multi dimension array for placeholders, e.g [:name => $name]
		 * then for specifying optional arguments for the bindParam, use 3 dimensional array e.g [:name => [$name,"PDO::INT"] ]
		 * 
		 * @return mixed, returns a pdo object if successful, false otherwise
		 */
		public function prepare($query,$bind_data = null){
			//open connection incase
			$this->open($this->con_clone);
			$this->_bindings = $bind_data;
			$this->query_txt = trim($query);
			$this->prepared_txt = $this->query_txt;
			switch($this->db_type){
				case $this->db_types['mysqli']:
				$this->prepared_obj = $this->con->prepare($this->query_txt);
				$this->general_obj = $this->prepared_obj;
			break;
			default://pdo
			try{
				$this->prepared_obj = $this->con->prepare($this->query_txt);
				$this->general_obj = $this->prepared_obj;//this shit took my time,geez, cause i used general_obj in this->execute, wasn't working, 
				//had to do this, thanks to soffiyya shaa, i just remembered it as i was chatting with her :)
			}
			catch(PDOException $ex){
				$this->err_msg = $ex->getMessage();
			}
			}
			return $this->prepared_obj;
		}

		/**
		 * For setting $this->bind_type value
		 * @param string $value the value to set
		 */
		public function set_bind_type($value){
			$this->bind_type = isset($value) ? strtolower(trim($value)) : '';
		}

		/**
		 * For setting $this->bind_type value
		 * @param mixed $value the value to bind
		 * @param mixed $placeholder, only applicable to pdo
		 * @param string $data_type uses mysqli short form s(string),i(int),d(double),b(blob), for pdo, it only recognises s and i, defaults to $this->pdo_param_type
		 */
		public function bind($value,$placeholder='',$data_type = 's'){
			$data_type = isset($data_type) ? trim($data_type) : '';
			$d_type = '';
			switch($this->db_type){
				case $this->db_types['mysqli']:
					//switching data types
					switch($data_type){
						case 'i':
							$d_type = 'i';
						break;
						case 'b':
							$d_type = 'b';
						break;
						case 'd':
							$d_type = 'd';
						break;
						default:
							$d_type = 's';
					}

					if($this->bind_type == 'param')
					$this->general_obj->bind_param($d_type,$value);
					else
					$this->general_obj->bind_value($d_type,$value);
					
				break;
				default:
					//switching data types
					switch($data_type){
						case 'i':
							$d_type = PDO::PARAM_INT;
						break;
						case 's': 
							$d_type = PDO::PARAM_STR;
						break;
						default:
							$d_type = $this->pdo_param_type;
					}
				if($this->bind_type == 'param')
					$this->general_obj->bindParam($placeholder,$value,$d_type);
				else	
					$this->general_obj->bindValue($placeholder,$value,$d_type);

			}
		}

		/**
		 * for executing prepared statements
		 * 
		 * This works with the Query::prepare() method too
		 * 
		 * @param array $bind_data(optional): the data to be bind, can be null if theres already a $this->_bindings to be used.
		 * @return bool
		 */
		public function execute($bind_data = null){
			//first, get the binding values and sort
			$result = false;
			if(!empty($bind_data) && is_array($bind_data)){//another set of data is to be bind
				$this->_bindings = $bind_data;
			}
			if(!empty($this->_bindings)){//carry on
				//check for which query it is
			switch($this->db_type){
				case $this->db_types['mysqli']:
					//bind the param so when looping, we assign $value, so
					//when looping, we change $value value and run
					$value;
				$this->general_obj->bind_param('s',$value);
				//loop through the array, to bind values
					for($i = 0; $i < count($this->_bindings); $i++){
						$value = $this->_bindings[$i];
						$result = $this->general_obj->execute();	
					}
					if($this->is_sql_error()){//an error along the line
						return false;//check for later
					}
				$this->general_obj->store_result();
				break;
				default: //pdo
				try{
					//loop through the array, to bind values
					for($i = 0, $j = 1; $i < count($this->_bindings); $i++){
						if(is_int($this->_bindings[$i])){
							$this->bind($this->_bindings[$i],$j,'i');
						}
						else{
							$this->bind($this->_bindings[$i],$j,'s');
						}
						$j++;
					}
				$result = $this->general_obj->execute();
				if($result == true)
					$this->clear_error();
				}
				catch(PDOException $ex){
					$this->err_msg = $ex->getMessage();
				}
			}
		}
			return $result;
		}

		/**
		 * Helps in closing the statement(prepared statements)
		 * 
		 * just like stmt->closeCursor() in PDO and  stmt->close() in mysql, should
		 * be called after the execute() method, has to be that way to work properly.
		 */
		public function close_statement(){
			if(!$this->prepared_obj){
				return false;
			}
			switch($this->db_type){
				case $this->db_types['mysqli'] :
					$this->prepared_obj->close();
				break;
				default: //pdo
					$this->prepared_obj->closeCursor();
			}
			//empty
			$this->prepared_obj = null;
			$this->query_obj = null;
			//$this->_bindings = null;
		}

		/**
		 * For counting records of a statement.
		 * 
		 * If it's not a select statement, it's the number of rows affected
		 * This should be used after execute() method, when used outside the class or
		 * when the class is initialised, if not,wont return anything
		 * 
		 * @return int returns the number of rows.
		 */
		public function count_rows(){
			$result = 0;
			if(!$this->prepared_obj && !$this->query_obj){//no statement
				return 0;
			}
			$obj = '';
			$obj_txt = '';
			if($this->prepared_obj && !$this->query_obj){//only prepared statement is not null
				$obj = $this->prepared_obj;
				$obj_txt = $this->prepared_txt;
			}
			else if(!$this->prepared_obj && $this->query_obj){//only query object isnt null
				$obj = $this->query_obj;
				$obj_txt = $this->query_txt;
			}
			else{//something is definitely wrong
				return 0;
			}
			//check if it's a select statement
			//continue
			switch($this->db_type){
					case $this->db_types['mysqli']:
						$obj->store_result();
						//check if it's a select statement
						if(in_array($this->get_statement_type($obj_txt),$this->sql_statement_for_count )){
							$obj->store_result();
							$result = $obj->num_rows;
							$this->row_count = $result;
							$obj->free_result();//free the result set.
						}
						else if(in_array($this->get_statement_type($obj_txt),$this->sql_statement_for_affected )){
							$obj->store_result();
							$result = $obj->affected_rows;
							$this->rows_affected = $result;
							
							$obj->free_result();//free the result set.
						}
						else{//its a random query
						}

					break;
					default://pdo
					//	$this->prepared_obj->storeResult();
					//var_dump($obj_txt);
						//check if it's a select statement
						if(in_array($this->get_statement_type($obj_txt),$this->sql_statement_for_count )){
							$obj->setFetchMode($this->fetch_mode);//should only be one mode, so we count normal value, instead of double.
							//add to the result_dummy
							$this->_record_dummy = $obj->fetchAll();
							//var_dump($this->_result_dummy);
							$result = count($this->_record_dummy);
							$this->row_count = $result;
						}
						else if(in_array($this->get_statement_type($obj_txt),$this->sql_statement_for_affected )){
							$obj->setFetchMode($this->fetch_mode);//should only be one mode, so we count normal value, instead of double.
							$result = $obj->rowCount();
							$this->rows_affected = $result;	
						}
						else{//its a random query
							
						}
			
						//$obj->closeCursor();
						//$this->close_statement();
			}
			return $result;
		}

		/**
		 * For getting records of a statement, usually a select statement 
		 * 
		 * This should be used after execute() method when used outside the class
		 * if not, returns false
		 * 
		 * @param bool $single(optional) if you should just get a single result or not, default is false
		 * @return array|false returns an array if true, if it's not a select statement, returns false.
		 */
		public function get_record($single = false){
			$result = false;
			if(!$this->prepared_obj && !$this->query_obj){//no statement
				return false;
			}
			$obj = '';
			$obj_txt = '';
			if($this->prepared_obj && !$this->query_obj){//only prepared statement is not null
				$obj = $this->prepared_obj;
				$obj_txt = $this->prepared_txt;
			}
			else if(!$this->prepared_obj && $this->query_obj){//only query object isnt null
				$obj = $this->query_obj;
				$obj_txt = $this->query_txt;
			}
			else{//something is definitely wrong
				return false;
			}
			
			//check if it's a select statement
			if(!in_array($this->get_statement_type($obj_txt),$this->sql_statement_for_count )){
				return false;
			}
			//continue
			switch($this->db_type){
				case $this->db_types['mysqli']://realised that fetch_all doesnt exist for mysqli prepared
				//statement, so we check
					if($single == true){
						if($this->prepared_obj){//its a prepared object, so fetch
						$obj->store_result();
					
							$result = $obj->fetch();
						}
						else{//normal statement
							$res = array();
						while($row = $this->general_obj->fetch_array($this->fetch_mode)){
							$res[] = $row;
						}
						$result = $res[0];
						}
					}
					else{//more than one result
					
						if($this->prepared_obj){//its a prepared object, so fetch
							echo "rrrrrrrrrrrrrrrrrrrrrr";
							$val = $this->general_obj->store_result();
							var_dump($val);
							//for the sake of older versions,
							//fetch_all() only exists in mysqli version > 5.3
							if($this->get_connection_info()->client_version < 50300){
								$res = array();
								while($row = $obj->fetch_array($this->fetch_mode)){
								$res[] = $row;
								}
								//$res[] = $obj->fetch_all($this->fetch_mode);
							#########################debugging	
								$result = $res;
							}
							else{
								
							$result = $obj->fetch_all();
							}
						}
						else{//normal statement
							$res = array();
						while($row = $obj->fetch_array($this->fetch_mode)){
							$res[] = $row;
						}
						$result = $res;
						}
						//$result = $obj->fetch_all($this->fetch_mode);
					}
					//check for error
					$this->is_sql_error();

					$this->record = $result;

				break;
				default://pdo
					//$obj->storeResult();
					try{
					if(!empty($this->_record_dummy)){
						//use the result dummy
						$result = $this->_record_dummy;
						$this->_record_dummy = array();//empty
					}
					else{//looks like count_rows() hasn't been called yet.
						$obj->setFetchMode($this->fetch_mode);
					if($single == true){//single result
						$result = $obj->fetch();
					}
					else{
						$result = $obj->fetchAll();
					}
					$this->row_count = count($result);//incase this method is called before row_count
				}
					$this->record = $result;
					$this->clear_error();
				}
				catch(PDOException $ex){
					$this->err_msg = $ex->getMessage();
				}

			}
			return $result;
		}
		
		/**
		 * To query the database, any valid query can go here, note if you use insert here, the last_insert_id wont be updated :), i'll later find a way to sort this out
		 * @param string $query : query to execute in the database
		 * @return bool true or false.
		 */		
		public function query($query){
			//open connection incase
			$this->open($this->con_clone);			
			$query = isset($query) ? trim($query) : '';
			$exec = $this->inner_query($query,5);
			//close the statements
			$this->close_statement();
			//close connection
			$this->close();
			
		}

		/**
		 * TO retrieve info from a table, works like the select bla
		 * @param string $query : query to execute in the database
		 * @param array $bind_data (optional) the values to bind in the query if need be, default value is null
		 * @param bool $single (optional) if it should store a single row, default is false
		 * @return bool true or false.
	  	 */		
		public function get($query,$bind_data = null,$single = false){
			//open connection incase
			$this->open($this->con_clone);
			$this->_bindings = $bind_data;
			$exec = $this->inner_query(trim($query),2);
			if(!empty($this->err_msg))//check if there's an error
				return false;
			switch($this->db_type){
				case $this->db_types['mysqli']:
					if(!empty($this->prepared_obj)){//it's a prepared statement
						//$this->prepared_obj->store_result();
						$this->row_count = $this->count_rows();
						$this->record = $this->get_record($single);
					}
					else{//it's a normal statement
						$this->row_count = $this->general_obj->num_rows;
						$this->record = $this->get_record($single);
						/*
						$this->record = $res;
						*///$this->general_obj->fetch_array($this->fetch_mode);//$res;
					}
						
				break;

				default://for pdo, getting a row count isn't easy, PDO::rowCount is not suitable for SELECT,
				//so fetch the results then count the array, my way :)
				try{//try getting the number of rows and all so it's stored in proper field
					//$this->row_count = $this->count_rows();
					$this->record = $this->get_record($single);
					$this->clear_error();
				}
				catch(PDOException $ex){
					$this->err_msg = $ex->getMessage();
				}
			}
			//close the statements
			$this->close_statement();
			//close connection
			$this->close();
			return $exec;
		}

		/**
		 * To update info in a table 
		 * 
		 * @param string $table, the table name.
		 * @param array $data, Data to update (in column => value pairs).
	     * @param string $condition: holds the conditions like using the where clause,it's optional
		 * @param array $bind_data(optional): for holding values to bind for a prepared query, default is null or empty.
		 * 
		 * @return bool true or false.
		*/
		public function change($table,$data = array(),$condition = "",$bind_data = array("")){
			//open connection incase
			$this->open($this->con_clone);
			$this->table = $table;
			$this->condition = $condition;
			$this->_bindings = $bind_data;
			//$this->content = (Query::columns($this->values));
			$statement = '';
			$i = 0;
			$len = count($data);
			foreach($data as $column => $val){
				$char = ",";
				if(($len - $i) == 1){//last value
				$char = '';
				}
				//check if it's a custom sql function
				if( in_array( strtolower($val) ,$this->sql_functions )){//its a special function
					$statement .= $column."=".$val.$char;
				}
				else{
					$statement .= $column."= '".$val."'".$char;
				}
				$i++;
			}
			$q = "UPDATE ".$table." SET ".$statement. " ".$this->condition;
			$exec = $this->inner_query($q,3);
			if(!empty($this->err_msg))//check if there's an error
				return false;
			$this->rows_affected = $this->count_rows();
			
			//close the statements
			$this->close_statement();
			//close connection
			$this->close();
			return $exec;
		}
		
		/**
		 * To add info into a table
		 * 
		 * @param string table: the name of the table
		 * @param array data: Data to insert (in column => value pairs)
 		 * @param array bind_data(optional): for holding values to bind for a prepared query, default is null or empty.
		 * 
		 * @return bool true or false.
		 */
		public function add($table,$data = array(),$bind_data = array("")){
			//open connection incase
			$this->open($this->con_clone);
			$this->table = $table;
			$this->_bindings = $bind_data;
			//$this->content = (Query::columns($this->values));
			$columns = '';
			$values = '';
			$i = 0;
			$len = count($data);
			
			foreach($data as $column => $val){
				$char = ",";
				if(($len - $i) == 1){//last value
				$char = '';
				}
				$columns .= $column.$char;
				//check if it's a custom sql function
				if( in_array( strtolower($val) ,$this->sql_functions )){//its a special function
					$values .= $val.$char;
				}
				else{
					$values .= "'".$val."'".$char;
				}
				$i++;
			}
			$q = "INSERT INTO ".$table." (".$columns.") VALUES(".$values.") ";
			$exec = $this->inner_query($q,1);
			if(!empty($this->err_msg))//check if there's an error	
				return false;
				$this->rows_affected = $this->count_rows();
			
			//close the statements
			$this->close_statement();
			//close connection
			$this->close();
			return $exec;
		}
		
		/**
		 * TO delete info from a table 
		 * 
		 * @param string table: The name of the table
		 * @param string condition(optional): the necessary condition for the query, e.g where id=1 limit 1. default value is ""
		 * @param array bind_data(optional): for holding values to bind for a prepared query, default is null or empty.
		 * 
		 * @return bool true or false.
		 */
		
		public function remove($table,$condition = "",$bind_data = array("")){
			//open connection incase
			$this->open($this->con_clone);
			$this->table = $table;
			$this->condition = $condition;
			$this->_bindings = $bind_data;
			//$this->content = (Query::columns($this->values));
			$q = "DELETE FROM ".$table." ".$this->condition;
			$exec = $this->inner_query($q,4);
			if(!empty($this->err_msg))//check if there's an error
				return false;
				$this->rows_affected = $this->count_rows();
			
			//close the statements
			$this->close_statement();
			//close connection
			$this->close();
			return $exec;
			//CALL THE DELETED CLASS
			//Deleted::delete($this->table,$this->token,$this->token_name);
		}
		
		/**
		 * THE QUERY THAT IS CALLED BY ALL THE FUNCTIONS
		 * 
		 * It's preferable you use ? for prepared statement stuff
		 * 
		 * @param string $query: the query string.
		 * @param int $token: to determine which to use
		 * 
		 * @return bool true or false.
		 */
		protected function inner_query($query,$token){
			$this->token = $token;
			// GET THE RESPECTIVE VALUES
			$insert = 1; //Insert request;
			$select = 2; //select request
			$update = 3;//update request;
			$delete = 4;//if it's a delete request;
			$q = $query;
			
			$this->query_txt = $q;
			$result = '';
			//check for which query it is
			switch($this->db_type){
				case $this->db_types['mysqli'] :
				if(strpos($query,'?') !== false  && ($this->_bindings != null || !empty($this->_bindings) )){//use prepared statements
					$this->prepared_txt = $this->query_txt;
					$this->prepared_obj = $this->con->prepare($q);
					$this->general_obj = $this->prepared_obj;
					$result = $this->execute();
					$this->last_insert_id = (int)$this->con->insert_id;//get the insert id
					echo "<br><br>fool";
					var_dump($this->general_obj);
			
					//if($this->is_sql_error()){
					//	return false;
					//}
					////reset the $this->prepared_obj so it goes back to normal
					//$this->prepared_obj = null;
				}
				else{//normal,
						if($this->token == $insert){
							$result = $this->con->exec($q);
							$this->last_insert_id = (int)$this->con->insert_id;//get the insert id
						}
						else if($this->token == $select){
							$result = $this->con->query($q);
						}
						else if($this->token == $update){
							$result = $this->con->exec($q);
						} 
						else if($this->token == $delete){
							$result = $this->con->exec($q);
						}
						else{//another type of query
							$result = $this->con->exec($q);
						}
						$this->query_obj = $result;
						$this->general_obj = $this->query_obj;
						if($this->is_sql_error()){//an error along the line
							return false;
						}
				}
		
				break;
				
				default :
					if(strpos($query,'?') !== false  && ($this->_bindings != null || !empty($this->_bindings) )){//use prepared statements
						$this->prepared_txt = $this->query_txt;
						try{
						$this->prepared_obj = $this->con->prepare($q);
						$this->general_obj = $this->prepared_obj;
						$result = $this->execute();
						$this->last_insert_id = (int)$this->con->lastInsertId();//get the insert id
						//if($result != false)//noticed it returned false, yet, it ran the try code, will inspect later
						//	$this->clear_error();
						}
						catch(PDOException $ex){
							$this->err_msg = $ex->getMessage();
						}
						////reset the $this->prepared_obj so it goes back to normal
						//$this->prepared_obj = null;
					}
					else{//normal,
						try{//determine if its select,update, etc.
							if($this->token == $insert){
								//$result = $this->con->exec($q);
								//testing
								$this->prepared_obj = $this->con->prepare($q);
								$this->general_obj = $this->prepared_obj;
								$result = $this->execute();
								//end of testing lines
								$this->last_insert_id = (int)$this->con->lastInsertId();//get the insert id
							}
							else if($this->token == $select){
								$result = $this->con->query($q);
							}
							else if($this->token == $update){
								$result = $this->con->exec($q);
							} 
							else if($this->token == $delete){
								$result = $this->con->exec($q);
							}
							else{//its another random query
								$result = $this->con->exec($q);
							}
							$this->query_obj = $result;
							$this->general_obj = $this->query_obj;
							if($result != false)//noticed it returned false, yet, it ran the try code, will inspect later
							$this->clear_error();
						}
						catch(PDOException $ex){
							$this->err_msg = $ex->getMessage();
						}
						//$this->query;
					}
			}
			
			return $result;
		}

		/**
		 * Clears the current error and updates the last error field 
		 * 
		 */
		private function clear_error(){
			$this->last_err_msg = $this->err_msg;
			$this->err_msg = null;
		}
		/**
		 * Checks if the current statement had an error
		 * 
		 * This is useful when some errors cant really be caught, did it especially
		 * for mysqli bla, checking everytime if mysqli::error is not empty is tiring 
		 * 
		 * @return bool true if there's an error, false otherwise
		 */
		private function is_sql_error(){
			switch($this->db_type){
				case $this->db_types['mysqli']:
					if($this->con->error){//error
						$this->err_msg = $this->con->error;
						return true;
					}
					else{//no error, clear error
						$this->clear_error();
						return false;
					}
				break;
				//no default, cause default is pdo

			}
		}

		/**
		 * Gets the statement type, e.g select,insert,etc.
		 * 
		 * @param string $str the statement
		 * @return string the first 6 letters, which determines the type of statement
		 */
		private function get_statement_type($str){
			$str = strtolower($str);
			return substr(trim($str), 0, 6);
		}

		/**
		 * Helps set fetch mode of a returning array for the db result
		 * 
		 * @param mixed $mode (optional) the mode to be used, both , num, or assoc ones
		 * these values are put in, the method adjusts it to its suitable mode on the db driver. 
		 * default is num if value doesn't match any correct option.
		 */
		public function set_fetch_mode($mode = 'num'){
			switch($this->db_type){
				case $this->db_types['mysqli']:
					switch(strtolower(trim($mode))){
						case 'both':
						$this->fetch_mode = MYSQLI_BOTH;
						break;
						case 'assoc':
						$this->fetch_mode = MYSQLI_ASSOC;
						break;
						default:
						$this->fetch_mode = MYSQLI_NUM;
						break;
					}
				break;
				default:
				switch(strtolower(trim($mode))){
					case 'both':
					$this->fetch_mode = PDO::FETCH_BOTH;
					break;
					case 'assoc':
					$this->fetch_mode = PDO::FETCH_ASSOC;
					break;
					default:
					$this->fetch_mode = PDO::FETCH_NUM;
					break;
				}
			//(PDO::FETCH_NUM);//in later updates, this should be flexible		
			}
		}


	}
